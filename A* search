{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<h1>CS152 Assignment 1: The 8-puzzle</h1>\n",
    "\n",
    "<h3>Akmarzhan Abylay,\n",
    "February 2020</h3>\n",
    "    \n",
    "Before you turn in this assignment, make sure everything runs as expected. First, **restart the kernel** (in the menubar, select Kernel$\\rightarrow$Restart) and then run the test cells for each of the questions you have answered.  Note that a grade of 3 for the A* implementation requires all tests in the \"Basic Functionality\" section to be passed.  The test cells pass if they execute with no errors (i.e. all the assertions are passed).\n",
    "\n",
    "Make sure you fill in any place that says `YOUR CODE HERE`.  Be sure to remove the `raise NotImplementedError()` statements as you implement your code - these are simply there as a reminder if you forget to add code where it's needed."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "---"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "markdown",
     "checksum": "3582513581b2e5d1806ee2b1117ac019",
     "grade": false,
     "grade_id": "5bb4ce",
     "locked": true,
     "schema_version": 3,
     "solution": false
    }
   },
   "source": [
    "<h1>\n",
    "Question 1    \n",
    "</h1>\n",
    "Define your <code>PuzzleNode</code> class below.  Ensure that you include all attributes that you need to implement an A* search.  If you wish, you can even include member functions, such as a function to generate successor states.  Alternatively, you can code up this functionality later in the <code>solvePuzzle</code> function."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We are about to implement a search here, which resembles a process of looking for a sequence of actions to get from the initial state to the goal state. Before starting, we need to understand the task by defining the problem. \n",
    "\n",
    "**Problem definition:**\n",
    "- **Initial state**: We have a starting state, which contains $n^2-1$ tiles and 1 blank tile in any configuration. \n",
    "- **Actions:** The available actions are to swap the blank tile with any of the adjacent tiles (i.e., to \"move\" the tiles around). Depending on the position of the blank tile in the puzzle, 2, 3, or 4 moves can be possible. \n",
    "- **Transition Model**: If we have a tile above the blank space, we will end up moving the tile down. If we have a tile below the blank space, we will end up moving the tile up. If we have a tile to the right of the blank space, we will end up moving the tile to the left. If we have a tile to the left of the blank space, we will end up moving the tile to the right.\n",
    "    - **Successor states**, in this case, are all the reachable states from the given states (maximum of 4 child states for a given state). \n",
    "    - **State-space** of the problem is a set of all reachable states from the initial state by any sequence of actions. \n",
    "- **Goal state**: A sorted puzzle with 0 as the first item of the first column and all other ascending numbers (from 1 to $n^2-1$) afterward until the n-by-n puzzle is formed (e.g., 0-1-2, 3-4-5, 6-7-8)\n",
    "    - **Optimal path**, in this case, would be the shortest sequence of states/actions to reach the goal state. \n",
    "    \n",
    "To solve this problem, we would have to break it down to pieces, which were already given in the assignment. We will first look at the state representations in the `PuzzleNode`, then at the heuristics in question 2, and the actual solver in `solvePuzzle`. \n",
    "\n",
    "The first step in creating the `PuzzleNode` class would be to find a way to represent the unique states. We will use 1-d arrays to do that since they are straightforward in use and will reflect the internal ordering of the tiles. Also, the indices of the array, which cannot be changed, could represent the fixed locations of the tiles. We will use integers to represent the numbers in the tiles, while 0 will be the blank space. We will also add different properties, such as the h-value or f-value. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {
    "deletable": false,
    "nbgrader": {
     "cell_type": "code",
     "checksum": "4326143183f9b58edcedbc64aed31100",
     "grade": false,
     "grade_id": "b5da05",
     "locked": false,
     "schema_version": 3,
     "solution": true,
     "task": false
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "5 2 6\n",
      "3 8 7\n",
      "1 4 0\n"
     ]
    }
   ],
   "source": [
    "#importing the needed libraries\n",
    "import numpy as np \n",
    "import random\n",
    "\n",
    "class PuzzleNode():\n",
    "    \n",
    "    \"\"\"\n",
    "    Class PuzzleNode: Provides a structure for performing A* search for the n^2-1 puzzle\n",
    "    \"\"\"\n",
    "    \n",
    "    def __init__(self, n, fval = 0, gval = 0, hval = 0, parent = None, state = None):\n",
    "        \n",
    "        #puzzle node attributes\n",
    "        self.n = n \n",
    "        self.parent = parent  #parent node (state) - predecessor \n",
    "        self.hval = hval #estimated cost of the cheapest path to the goal state\n",
    "        self.gval = gval  #path cost\n",
    "        self.fval = fval  #path + heuristic cost - estimated cost of the cheapest path through n (this state)\n",
    "        self.pruned = False   #indicator of whether this node and its children were pruned\n",
    "        \n",
    "        #if no state was provided, makes up a random state\n",
    "        state_1d = random.sample(range(self.n**2), self.n**2) if state is None else state\n",
    "        \n",
    "        #reshapes the array so that it fits the dimensions n x n\n",
    "        #I am using a 2d array for this exact implementation, since it is very convenient for representing n-by-n puzzles. \n",
    "        self.state = np.array(state_1d).reshape(self.n, self.n)\n",
    "        \n",
    "    def __str__(self):\n",
    "        \n",
    "        \"\"\"Returns an n x n board that resembles the puzzle state.\"\"\"\n",
    "        \n",
    "        return('\\n'.join(' '.join('{:d}'.format(\n",
    "            item) for item in row) for row in self.state))\n",
    "    \n",
    "    def solved(self):\n",
    "        \n",
    "        \"\"\"Checks if puzzle is already in the solved state.\"\"\"\n",
    "        \n",
    "        return(np.array_equal(self.state, np.arange(self.n**2).reshape(self.n, self.n)))\n",
    "    \n",
    "    def __lt__(self, other): \n",
    "        \n",
    "        \"\"\"Compares the f-values of the states in the search. Implemented by the priority queue which identifies\n",
    "        the priority by the f-value.\"\"\"\n",
    "        \n",
    "        return self.fval < other.fval\n",
    "         \n",
    "print(PuzzleNode(3))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "markdown",
     "checksum": "f523db3048f85be39ef3dc740b53fdba",
     "grade": false,
     "grade_id": "859d2c",
     "locked": true,
     "schema_version": 3,
     "solution": false
    }
   },
   "source": [
    "<h1>\n",
    "Question 2    \n",
    "</h1>\n",
    "Define your heuristic functions using the templates below.  Ensure that you extend the <code>heuristics</code> list to include all the heuristic functions you implement.  Note that state will be given as a list of lists, so ensure your function accepts this format.  You may use packages like numpy if you wish within the functions themselves."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We will use the A* search to implement this search (which we will talk about in question 3). One of the main features of this type of search, which makes it stand out is that it estimates the cost of the cheapest solution through the given node (**f(n)** value) by combining **g(n)**, the cost to reach to the node, and **h(n)**, the cost to get from the node to the goal. \n",
    "\n",
    "The h(n) is found through the use of heuristics, which estimate the cost of the path from the node to the goal. There are many different heuristics we can use, but to ensure optimality for our graph search (i.e., guarantee that we find the shortest solution), we need to ensure both **admissibility** and **consistency/monotonicity** of the heuristic. Admissibility is when the heuristic never overestimates the cost to reach the goal, and which is optimistic since it thinks that the cost is lower than it actually is. At the same time, consistency is when for every node n and every successor n' of n generated by any action, the estimated cost of reaching the goal from n is not greater than the step cost of getting to n' plus the estimated cost of reaching the goal from n': $h(n) â‰¤ c(n, a, n') + h(n')$. \n",
    "\n",
    "We need to understand whether a move is good or bad, which is why we are using heuristics to determine which move is better than the other. The first two heuristics (i.e., misplaced tiles and Manhattan) we are using are both admissible and consistent (which could be easily proved by general triangle inequality, where each side of a triangle cannot be longer than the sum of the other two sides). Consistency is a stricter requirement than admissibility, but this is what ensures the graph search to be optimal. If we were working with tree search, we wouldn't have had the closed list (i.e., explored set), and we would have just needed to prove admissibility.  \n",
    "\n",
    "A number of misplaced tiles is simply the number of blocks that are not in their right positions, while the Manhattan distance is the sum of the absolute differences in the current and goal state column numbers and row numbers. \n",
    "\n",
    "For example, for the initial state `2-3-7-1-8-0-6-5-4`, there are 7 misplaces tiles, and the Manhattan distance is 15 since we don't count 0 because it is a blank space. \n",
    "\n",
    "The third heuristic is the linear conflicts heuristic. We say that two tiles j and k are in a linear conflict if j and k and their goal positions are all in the same line (columns count too) and j is to the right of k, and the goal position of j is to the left of the goal position of k. We add this doubled minimum number of extra moves that are necessary for resolving the conflicts within each row and column to the Manhattan distance and get the value from the heuristic of linear conflicts. This heuristic is consistent, and the proof could be found here: https://academiccommons.columbia.edu/doi/10.7916/D8154QZT/download on page 15. I adapted the pseudo-code for the linear conflicts from there. \n",
    "\n",
    "Let's implement these heuristics below. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {
    "deletable": false,
    "nbgrader": {
     "cell_type": "code",
     "checksum": "686c6cabd6955171ad70aa6fd37d31a9",
     "grade": false,
     "grade_id": "3fb850",
     "locked": false,
     "schema_version": 3,
     "solution": true,
     "task": false
    }
   },
   "outputs": [],
   "source": [
    "#Misplaced tiles heuristic\n",
    "def h1_misplaced(state):\n",
    "    \n",
    "    \"\"\"\n",
    "    This function returns the number of misplaced tiles, given the board state\n",
    "    Input:\n",
    "        -state: the board state as a list of lists\n",
    "    Output:\n",
    "        -h: the number of misplaced tiles\n",
    "    \"\"\"\n",
    "        \n",
    "    #for all tiles (except 0 since it is not a tile), see whether they are misplaced or not \n",
    "    h = 0\n",
    "    for i in range(len(state)**2): \n",
    "        if (np.array(state).flatten())[i] != 0:\n",
    "            if (np.array(state).flatten())[i] != i:\n",
    "                    h += 1\n",
    "    return h\n",
    "\n",
    "#Manhattan distance heuristic\n",
    "def h2_manhattan(state):  \n",
    "    \n",
    "    \"\"\"\n",
    "    This function returns the Manhattan distance from the solved state, given the board state\n",
    "    Input:\n",
    "        -state: the board state as a list of lists\n",
    "    Output:\n",
    "        -h: the Manhattan distance from the solved configuration\n",
    "    \"\"\"\n",
    "    \n",
    "    #for all tiles (except 0 since it is not a tile), see what their Manhattan distance is based \n",
    "    #on how many columns and rows they are off\n",
    "    h = 0\n",
    "    for i, item in enumerate(np.array(state).flatten()):\n",
    "        if item != 0:\n",
    "            init_row, init_col = int(i/3) , i%3\n",
    "            goal_row, goal_col = int(item/3), item%3\n",
    "            h += abs(init_row-goal_row) + abs(init_col - goal_col)\n",
    "    return h\n",
    "\n",
    "#Linear Conflicts\n",
    "def h3_conflicts(state):\n",
    "    \n",
    "    \"\"\"\n",
    "    This function returns a heuristic that dominates the Manhattan distance, given the board state\n",
    "    Input:\n",
    "        -state: the board state as a list of lists\n",
    "    Output:\n",
    "        -h: the Heuristic distance of the state from its solved configuration\n",
    "    \"\"\"\n",
    "    \n",
    "    #we need to find the largest value tile which is k in each column/row and store the position of its goal position\n",
    "    maxk_row = {}\n",
    "    maxk_col = {} \n",
    "    lc = 0\n",
    "    \n",
    "    for init_row, rows in enumerate(state):\n",
    "        #looking at each tile from each row, where j is the j tile\n",
    "        for init_col, j in enumerate(rows):\n",
    "            \n",
    "            #finding the correct location for the tile j\n",
    "            goal_row, goal_col = j//len(state), j%len(state)\n",
    "            \n",
    "            #ignoring the 0 tile, since it can't have a conflict\n",
    "            if j == 0:\n",
    "                continue \n",
    "\n",
    "            #checking if the tile j is currently in the correct row\n",
    "            if init_row == goal_row: \n",
    "                #if we don't have the needed value in the dictionary, or j's goal column\n",
    "                #is larger than k's goal column (k found earlier is not the max in this line)\n",
    "                if init_row not in maxk_row or maxk_row[init_row] < goal_col:\n",
    "                    #update the max for this row\n",
    "                    maxk_row[init_row] = goal_col\n",
    "                     \n",
    "                #if the value is in the dictionary and if j's goal column is smaller than k's \n",
    "                #goal column. j's value is smaller than the value of k \n",
    "                #and located to the right of k, and j's goal position is to the left of k's goal position\n",
    "                #and we found a linear conflict\n",
    "                elif init_row in maxk_row and maxk_row[init_row] > goal_col:\n",
    "                    lc += 1\n",
    "                    \n",
    "            #checking if the tile j is currently in the correct column\n",
    "            #repeating the same steps for the columns of the state\n",
    "            elif init_col == goal_col: \n",
    "                if init_col not in maxk_col or goal_row > maxk_col[init_col]:\n",
    "                    maxk_col[init_col] = goal_row\n",
    "                    \n",
    "                elif init_col in maxk_col and maxk_col[init_col] > goal_row:                \n",
    "                    lc += 1\n",
    "    #finding the actual linear conflicts heuristic value by definition                \n",
    "    h = h2_manhattan(state) + 2*lc\n",
    "    return h\n",
    "\n",
    "# If you implement more than 3 heuristics, then add any extra heuristic functions onto the end of this list.\n",
    "heuristics = [h1_misplaced, h2_manhattan, h3_conflicts]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "markdown",
     "checksum": "591174c27300d0a4d4d96ee841e46810",
     "grade": false,
     "grade_id": "e224d9",
     "locked": true,
     "schema_version": 3,
     "solution": false
    }
   },
   "source": [
    "<h1>\n",
    "Question 3    \n",
    "</h1>\n",
    "Code up your A* search using the SolvePuzzle function within the template below.  Please do not modify the function header, otherwise the automated testing will fail.  You may define other functions or import packages as needed in this cell or by adding additional cells."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "As described above, A* search is an informed search algorithm, which uses a combined f(n) value as the cost function. It maintains a graph of paths that originates at the initial state node and extends those paths (one edge at a time) until it reaches the goal state (or meets the other termination criteria). At each iteration, it needs to identify which path to extend. Hence, as we discussed above, it uses the cost of the path to the node and the cheapest estimated cost of the path from the node to the goal node combined as its f(n) value, which it will try to minimize, where $f(n)=h(n)+g(n)$ and n is the next node in the path. It also records the nodes already visited in the explored set, so that we don't have to visit them several times, which reduces the time complexity. Since we have admissible heuristics, A* search is guaranteed to find the optimal solution, and it is also complete (since it does find a solution if there is one). \n",
    "\n",
    "We will implement a priority queue to perform a repeated selection of the minimum cost nodes for expansion. At each step, these lowest cost (f(n)) nodes are removed from the queue, and the f and g values of their children are updated accordingly, after which they are added to the queue too. My algorithm below continues until the goal node is reached (it has a smaller f value than any other node in the queue) or until the priority queue is empty. The optimal path is then found (not only the length, which is just the end/goal node f value, since h(n)=0) with all the medium states to solve the puzzle through the use of parent property in the `PuzzleNode` class. \n",
    "\n",
    "It is better than others when dealing with search problems like this, since A* is optimally efficient, meaning that no other algorithm is guaranteed to expand fewer nodes than A* (with few edge case exceptions). However, we are also keeping track of all the expanded nodes, which makes its space complexity $O(b^d)$ with the maximum branching factor of 4, and d is the depth of the shallowest solution."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {
    "deletable": false,
    "nbgrader": {
     "cell_type": "code",
     "checksum": "91dda09c4f5df1db4607bb3b82e81afd",
     "grade": false,
     "grade_id": "328d7b",
     "locked": false,
     "schema_version": 3,
     "solution": true
    }
   },
   "outputs": [],
   "source": [
    "from queue import PriorityQueue #for the frontier \n",
    "\n",
    "def solvable(state):\n",
    "        \n",
    "    \"\"\"Checks if the given state is solvable with respect to the goal state\n",
    "    Input:\n",
    "        -state: the board state as a list of lists\n",
    "    Output:\n",
    "        -True/False: a boolean that represents whether a state is solvable or not. \n",
    "    \"\"\"\n",
    "        \n",
    "    flat_state = np.array(state)\n",
    "        \n",
    "    #making up a parity state to check for inversions (excluding the 0)\n",
    "    inversion_state = np.delete(flat_state.flatten(), np.argwhere(flat_state.flatten() == 0))\n",
    "    inversions = 0 #inversion counter\n",
    "       \n",
    "    #counting the inversions for each tile\n",
    "    for i, tile in enumerate(inversion_state):\n",
    "        for next_tile in inversion_state[(i+1):]:\n",
    "            if next_tile < tile:\n",
    "                inversions += 1\n",
    "        \n",
    "    #solvability for odd n x n puzzles\n",
    "    if len(flat_state)%2 == 1:\n",
    "        if inversions%2 == 1: \n",
    "            return(False)\n",
    "        else:\n",
    "            return(True)\n",
    "    #solvability for even n x n puzzles\n",
    "    else:\n",
    "        #column in which 0 is located \n",
    "        zero_column = (flat_state.flatten().tolist().index(0)+1)%len(state)+1\n",
    "        if (len(state)-zero_column)%2 == 0 and inversions%2 == 1:\n",
    "            return True\n",
    "        elif (len(state)-zero_column)%2 == 1 and inversions%2 == 0:\n",
    "            return True\n",
    "        else:\n",
    "            return False\n",
    "    return True\n",
    "            \n",
    "def solvePuzzle(state, heuristic):\n",
    "    \n",
    "    \"\"\"This function should solve the n**2-1 puzzle for any n > 2 (although it may take too long for n > 4)).\n",
    "    Inputs:\n",
    "        -state: The initial state of the puzzle as a list of lists\n",
    "        -heuristic: a handle to a heuristic function.  Will be one of those defined in Question 2.\n",
    "    Outputs:\n",
    "        -steps: The number of steps to optimally solve the puzzle (excluding the initial state)\n",
    "        -exp: The number of nodes expanded to reach the solution\n",
    "        -max_frontier: The maximum size of the frontier over the whole search\n",
    "        -opt_path: The optimal path as a list of list of lists.  That is, opt_path[:,:,i] should give a list of lists\n",
    "                    that represents the state of the board at the ith step of the solution.\n",
    "        -err: An error code.  If state is not of the appropriate size and dimension, return -1.  For the extention task,\n",
    "          if the state is not solvable, then return -2\n",
    "    \"\"\"\n",
    "    \n",
    "    #initializing the needed variables \n",
    "    exp = 0\n",
    "    max_frontier = 0\n",
    "    opt_path = {} #set that represents the optimal path\n",
    "    n = len(state)\n",
    "\n",
    "    #checking for inconsistencies for error -1\n",
    "    dimensions = n > 2 #if the puzzle size fits the criteria (n>2)\n",
    "    subsize = set(map(len, state)) == {n} #appropriate dimensions  \n",
    "    elements = sorted(np.array(state).flatten().tolist()) == list(range(n**2)) #appropriate form and size\n",
    "    #whether the sorted flattened state is the same as the goal state\n",
    "    \n",
    "    if not all([dimensions, subsize, elements]):\n",
    "        opt_path = None\n",
    "        error = -1\n",
    "        return (0, 0, 0, None, error)\n",
    "    \n",
    "    #checking for solvability\n",
    "    if not solvable(state):\n",
    "        error = -2\n",
    "        return(0, 0, 0, None, error)\n",
    "    \n",
    "    #setting up the state as an object from class PuzzleNode\n",
    "    init_node = PuzzleNode(n, fval = heuristic(state), state = state)\n",
    "    node_goal = np.arange(n**2).reshape((n,n))\n",
    "    \n",
    "    #a dictionary of explored states (PuzzleNode class) linked to their flattened versions\n",
    "    explored = {tuple(init_node.state.flatten()):init_node}\n",
    "    \n",
    "    #set of leaf nodes available for expansion initialized as a Priority Queue \n",
    "    frontier = PriorityQueue()\n",
    "    frontier.put(init_node)\n",
    "    max_frontier = frontier.qsize() \n",
    "    \n",
    "    while not frontier.empty(): #looping while there are no more elements in the queue\n",
    "        \n",
    "        cur_node = frontier.get() #getting the highest priority node - least f-value\n",
    "        \n",
    "        #if the current state is already a goal state, break\n",
    "        if cur_node.solved():\n",
    "            break\n",
    "        \n",
    "        #if the node was pruned, skip to the next element in the frontier\n",
    "        if cur_node.pruned:\n",
    "            continue \n",
    "        \n",
    "        #location of the black tile - 0\n",
    "        blank_tile = tuple(*np.argwhere(np.array(cur_node.state) == 0))\n",
    "        \n",
    "        movements = [(-1,0),(0,-1),(1,0),(0,1)] #existing movements\n",
    "        \n",
    "        #finding out the valid moves for a given state from which to further get to next states\n",
    "        #based on the location of the blank tile since we can only swap it with adjacent tiles\n",
    "        pos_moves=[]\n",
    "        for move in movements:\n",
    "            pos_moves.append(tuple([sum(x) for x in zip(blank_tile, move) if 0 <= sum(x) < n]))\n",
    "        \n",
    "        valid_moves = [move for move in pos_moves if len(move) == 2]\n",
    "        \n",
    "        for move in valid_moves: #new child state for each move in the valid moves list\n",
    "            #cost of a child for the current node\n",
    "            gval = cur_node.gval + 1 \n",
    "            \n",
    "            #creating child state configurations by making moves - swapping the blank tile with some adjacent tile\n",
    "            next_state = np.copy(cur_node.state)\n",
    "            next_state[blank_tile], next_state[move] = next_state[move], next_state[blank_tile] \n",
    "            \n",
    "            #checking if the child state was already explored\n",
    "            if tuple(next_state.flatten()) in explored:\n",
    "                #checking if the g-value of the child is higher than the g-value of the current node\n",
    "                if explored[tuple(next_state.flatten())].gval > gval:\n",
    "                    #if yes, prune the branch\n",
    "                    explored[tuple(next_state.flatten())].pruned = True\n",
    "                else:\n",
    "                    continue\n",
    "                    \n",
    "            #generating h-value\n",
    "            hval = heuristic(next_state)\n",
    "            \n",
    "            #creating the child node\n",
    "            node_next = PuzzleNode(n, fval = gval+hval, hval = hval, gval = gval, parent = cur_node, state = next_state)\n",
    "            frontier.put(node_next) #adding the child node to the priority queue\n",
    "            \n",
    "            #adding the child node to the explored set too, since we have explored it \n",
    "            explored[tuple(next_state.flatten())] = node_next\n",
    "            exp += 1 \n",
    "            \n",
    "        #update the max frontier size if relevant\n",
    "        if frontier.qsize() > max_frontier:\n",
    "            max_frontier = frontier.qsize()\n",
    "        \n",
    "    #if the current is solved, produce the optimal path\n",
    "    if cur_node.solved(): \n",
    "        opt_path = []\n",
    "        error = 0\n",
    "        \n",
    "        #while there are still parent nodes, continue adding to the optimal path\n",
    "        while cur_node is not None: \n",
    "            opt_path.insert(0, cur_node.state.tolist()) #add the parent of the current node \n",
    "            cur_node = cur_node.parent #update the current node to be the parent of itself\n",
    "        \n",
    "        steps = len(opt_path)-1 #number of steps it takes to reach the goal \n",
    "        \n",
    "        #TO SEE THE STEPS AND INFORMATION, UNCOMMENT THIS\n",
    "        #------------------------------------------------\n",
    "        \n",
    "#         print(f\"{steps} steps to solve the puzzle. Max frontier size:{max_frontier}\")\n",
    "#         for i, node in enumerate(opt_path[::]):\n",
    "#             print(f\"{i}: \\n\", list(list(j) for j in node))\n",
    "            \n",
    "    return(steps, exp, max_frontier, opt_path, 0)\n",
    "    "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "markdown",
     "checksum": "c89ea5c4d80cc73d321b4d15a043e8b7",
     "grade": false,
     "grade_id": "fb9ccd",
     "locked": true,
     "schema_version": 3,
     "solution": false
    }
   },
   "source": [
    "<h1>Basic Functionality Tests</h1>\n",
    "The cells below contain tests to verify that your code is working properly to be classified as basically functional.  Please note that a grade of <b>3</b> on #aicoding and #search as applicable for each test requires the test to be successfully passed.  <b>If you want to demonstrate some other aspect of your code, then feel free to add additional cells with test code and document what they do.<b>"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "code",
     "checksum": "f8d927b41dc95f7b76d81ed7f6cd13ec",
     "grade": true,
     "grade_id": "8fbc24",
     "locked": true,
     "points": 1,
     "schema_version": 3,
     "solution": false
    }
   },
   "outputs": [],
   "source": [
    "## Test for state not correctly defined\n",
    "\n",
    "incorrect_state = [[0,1,2],[2,3,4],[5,6,7]]\n",
    "_,_,_,_,err = solvePuzzle(incorrect_state, lambda state: 0)\n",
    "assert(err == -1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "code",
     "checksum": "005a7a99916dafeb7180172c66365597",
     "grade": true,
     "grade_id": "cell-5738a2124877e52e",
     "locked": true,
     "points": 2,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "outputs": [],
   "source": [
    "## Heuristic function tests for misplaced tiles and manhattan distance\n",
    "\n",
    "# Define the working initial states\n",
    "working_initial_states_8_puzzle = ([[2,3,7],[1,8,0],[6,5,4]], [[7,0,8],[4,6,1],[5,3,2]], [[5,7,6],[2,4,3],[8,1,0]])\n",
    "\n",
    "# Test the values returned by the heuristic functions\n",
    "h_mt_vals = [7,8,7]\n",
    "h_man_vals = [15,17,18]\n",
    "\n",
    "for i in range(0,3):\n",
    "    h_mt = heuristics[0](working_initial_states_8_puzzle[i])\n",
    "    h_man = heuristics[1](working_initial_states_8_puzzle[i])\n",
    "    assert(h_mt == h_mt_vals[i])\n",
    "    assert(h_man == h_man_vals[i])\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "code",
     "checksum": "293094319e63d67c5f6d94cd7aee0c02",
     "grade": true,
     "grade_id": "cell-99c07d9541559b52",
     "locked": true,
     "points": 4,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "outputs": [],
   "source": [
    "## A* Tests for 3 x 3 boards\n",
    "## This test runs A* with both heuristics and ensures that the same optimal number of steps are found\n",
    "## with each heuristic.\n",
    "\n",
    "# Optimal path to the solution for the first 3 x 3 state\n",
    "opt_path_soln = [[[2, 3, 7], [1, 8, 0], [6, 5, 4]], [[2, 3, 7], [1, 8, 4], [6, 5, 0]], \n",
    "                 [[2, 3, 7], [1, 8, 4], [6, 0, 5]], [[2, 3, 7], [1, 0, 4], [6, 8, 5]], \n",
    "                 [[2, 0, 7], [1, 3, 4], [6, 8, 5]], [[0, 2, 7], [1, 3, 4], [6, 8, 5]], \n",
    "                 [[1, 2, 7], [0, 3, 4], [6, 8, 5]], [[1, 2, 7], [3, 0, 4], [6, 8, 5]], \n",
    "                 [[1, 2, 7], [3, 4, 0], [6, 8, 5]], [[1, 2, 0], [3, 4, 7], [6, 8, 5]], \n",
    "                 [[1, 0, 2], [3, 4, 7], [6, 8, 5]], [[1, 4, 2], [3, 0, 7], [6, 8, 5]], \n",
    "                 [[1, 4, 2], [3, 7, 0], [6, 8, 5]], [[1, 4, 2], [3, 7, 5], [6, 8, 0]], \n",
    "                 [[1, 4, 2], [3, 7, 5], [6, 0, 8]], [[1, 4, 2], [3, 0, 5], [6, 7, 8]], \n",
    "                 [[1, 0, 2], [3, 4, 5], [6, 7, 8]], [[0, 1, 2], [3, 4, 5], [6, 7, 8]]]\n",
    "\n",
    "astar_steps = [17, 25, 28]\n",
    "for i in range(0,3):\n",
    "    steps_mt, expansions_mt, _, opt_path_mt, _ = solvePuzzle(working_initial_states_8_puzzle[i], heuristics[0])\n",
    "    steps_man, expansions_man, _, opt_path_man, _ = solvePuzzle(working_initial_states_8_puzzle[i], heuristics[1])\n",
    "    # Test whether the number of optimal steps is correct and the same\n",
    "    assert(steps_mt == steps_man == astar_steps[i])\n",
    "    # Test whether or not the manhattan distance dominates the misplaced tiles heuristic in every case\n",
    "    assert(expansions_man < expansions_mt)\n",
    "    # For the first state, test that the optimal path is the same\n",
    "    if i == 0:\n",
    "        assert(opt_path_mt == opt_path_soln)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "code",
     "checksum": "94ad7f950f87fcc281af1f3946c4e196",
     "grade": true,
     "grade_id": "cell-2981ba2cc7745c22",
     "locked": true,
     "points": 8,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "outputs": [],
   "source": [
    "## A* Test for 4 x 4 board\n",
    "## This test runs A* with both heuristics and ensures that the same optimal number of steps are found\n",
    "## with each heuristic.\n",
    "\n",
    "working_initial_state_15_puzzle = [[1,2,6,3],[0,9,5,7],[4,13,10,11],[8,12,14,15]]\n",
    "steps_mt, expansions_mt, _, _, _ = solvePuzzle(working_initial_state_15_puzzle, heuristics[0])\n",
    "steps_man, expansions_man, _, _, _ = solvePuzzle(working_initial_state_15_puzzle, heuristics[1])\n",
    "# Test whether the number of optimal steps is correct and the same\n",
    "assert(steps_mt == steps_man == 9)\n",
    "# Test whether or not the manhattan distance dominates the misplaced tiles heuristic in every case\n",
    "assert(expansions_mt >= expansions_man)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "markdown",
     "checksum": "93712bce8426499023ace13735ea998d",
     "grade": false,
     "grade_id": "cell-3fc6e687e03655a1",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "source": [
    "<h1>Extension Questions</h1>\n",
    "\n",
    "The extensions can be implemented by modifying the code from Q2-3 above appropriately.\n",
    "\n",
    "1. <b>Initial state solvability:</b>  Modify your SolvePuzzle function code in Q3 to return -2 if an initial state is not solvable to the goal state.\n",
    "2. <b>Extra heuristic function:</b> Add another heuristic function (e.g. pattern database) that dominates the misplaced tiles and Manhattan distance heuristics to your Q2 code.\n",
    "3. <b>Memoization:</b>  Modify your heuristic function definitions in Q2 by using a Python decorator to speed up heuristic function evaluation\n",
    "\n",
    "There are test cells provided for extension questions 1 and 2."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "markdown",
     "checksum": "7251e4aad7b1e19b42a78e54d8e7b920",
     "grade": false,
     "grade_id": "cell-2c262efb90518641",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "source": [
    "<h1>Extension Tests</h1>\n",
    "The cells below can be used to test the extension questions.  Memoization if implemented will be tested on the final submission - you can test it yourself by testing the execution time of the heuristic functions with and without it."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "1. **Initial State Solvability**\n",
    "\n",
    "I have added the code above in question 3 above the `solvePuzzle` function. It works using the following logic. \n",
    "\n",
    "In general, if we are given an n-by-n puzzle, we can find out if the $n^2-1$ is solvable or not by looking at the inversions and the location of the blank tile in the puzzle. **Inversion** here is any pair of tiles *i* and *j* for which *i < j* but *i* is located after *j* (to the right) when considering the flattened version of the state (1-d array) and excluding the blank tile. We are also specifically interested in the column number of the blank tile counting from the bottom row.\n",
    "\n",
    "If n is odd, then the puzzle is solvable if the number of inversions is even, while it is not solvable if it is odd. At the same time, if n is even, then the puzzle is solvable if the number of inversions is odd, and the blank is on an even row counting from the bottom, as well as then the number of inversions is even, and the blank is on an odd row. In other cases, the puzzle is unsolvable. \n",
    "\n",
    "Finding these simple rules is essential because we must know whether it is worth spending computational power and whether we will get to the goal state from the initial state. For example, if we didn't know that a puzzle is unsolvable, we would have wasted a lot of time and power to solve it, but it could run until it explored all state space for nothing, since it is impossible to reach the goal state from that specific initial state. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "code",
     "checksum": "efc4b74c95e814a4fb07d2c5ed26f337",
     "grade": true,
     "grade_id": "cell-21cada9978e9a1bb",
     "locked": true,
     "points": 16,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "outputs": [],
   "source": [
    "## Puzzle solvability test\n",
    "\n",
    "unsolvable_initial_state = [[7,5,6],[2,4,3],[8,1,0]]\n",
    "_,_,_,_,err = solvePuzzle(unsolvable_initial_state, lambda state: 0)\n",
    "assert(err == -2)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "2. **Extra Heuristic Function**\n",
    "\n",
    "The explanation is above in Question 2. I implemented a linear conflicts heuristic. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "code",
     "checksum": "9b7ebb02bcf675ab3a5157eaa1155763",
     "grade": true,
     "grade_id": "cell-8c7a414efc152379",
     "locked": true,
     "points": 32,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "outputs": [],
   "source": [
    "## Extra heuristic function test.  \n",
    "## This tests that for all initial conditions, the new heuristic dominates over the manhattan distance.\n",
    "\n",
    "dom = 0\n",
    "for i in range(0,3):\n",
    "    steps_new, expansions_new, _, _, _ = solvePuzzle(working_initial_states_8_puzzle[i], heuristics[2])\n",
    "    steps_man, expansions_man, _, _, _ = solvePuzzle(working_initial_states_8_puzzle[i], heuristics[1])\n",
    "    # Test whether the number of optimal steps is correct and the same\n",
    "    assert(steps_new == steps_man == astar_steps[i])\n",
    "    # Test whether or not the manhattan distance is dominated by the new heuristic in every case, by checking\n",
    "    # the number of nodes expanded\n",
    "    dom = expansions_man - expansions_new\n",
    "assert(dom > 0)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "3. **Memoization**\n",
    "\n",
    "I have implemented this in a separate cell because it will mess up the original code if I put it in. Also, there are limitations to the input and output of the functions, so it is easier to make a new one and put it separately. Memoization here could be used for speeding up the execution of the code through saving and reusing the heuristic values that have already been calculated for the state previously, to avoid the same number being re-evaluated for a different puzzle example. Below we can see some tests, which show that initially, the memoized and original versions have the same running time, while for the second run after the `global_explored` set has been updated, the search runs faster (almost 3 seconds less). "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [],
   "source": [
    "global_explored = {}\n",
    "def solvePuzzle_memoization(state, heuristic):\n",
    "    \n",
    "    \"\"\"This function should solve the n**2-1 puzzle for any n > 2 (although it may take too long for n > 4)).\n",
    "    Inputs:\n",
    "        -state: The initial state of the puzzle as a list of lists\n",
    "        -heuristic: a handle to a heuristic function.  Will be one of those defined in Question 2.\n",
    "    Outputs:\n",
    "        -steps: The number of steps to optimally solve the puzzle (excluding the initial state)\n",
    "        -exp: The number of nodes expanded to reach the solution\n",
    "        -max_frontier: The maximum size of the frontier over the whole search\n",
    "        -opt_path: The optimal path as a list of list of lists.  That is, opt_path[:,:,i] should give a list of lists\n",
    "                    that represents the state of the board at the ith step of the solution.\n",
    "        -err: An error code.  If state is not of the appropriate size and dimension, return -1.  For the extention task,\n",
    "          if the state is not solvable, then return -2\n",
    "    \"\"\"\n",
    "    \n",
    "    #initializing the needed variables \n",
    "    exp = 0\n",
    "    max_frontier = 0\n",
    "    opt_path = {} #set that represents the optimal path\n",
    "    n = len(state)\n",
    "\n",
    "    #checking for inconsistencies for error -1\n",
    "    dimensions = n > 2 #if the puzzle size fits the criteria (n>2)\n",
    "    subsize = set(map(len, state)) == {n} #appropriate dimensions  \n",
    "    elements = sorted(np.array(state).flatten().tolist()) == list(range(n**2)) #appropriate form and size\n",
    "    #whether the sorted flattened state is the same as the goal state\n",
    "    \n",
    "    if not all([dimensions, subsize, elements]):\n",
    "        opt_path = None\n",
    "        error = -1\n",
    "        return (0, 0, 0, None, error)\n",
    "    \n",
    "    #checking for solvability\n",
    "    if not solvable(state):\n",
    "        error = -2\n",
    "        return(0, 0, 0, None, error)\n",
    "    \n",
    "    #setting up the state as an object from class PuzzleNode\n",
    "    init_node = PuzzleNode(n, fval = heuristic(state), state = state)\n",
    "    node_goal = np.arange(n**2).reshape((n,n))\n",
    "    \n",
    "    #a dictionary of explored states (PuzzleNode class) linked to their flattened versions\n",
    "    explored = {tuple(init_node.state.flatten()):init_node}\n",
    "    global_explored[tuple(init_node.state.flatten())] = init_node\n",
    "    \n",
    "    #set of leaf nodes available for expansion initialized as a Priority Queue \n",
    "    frontier = PriorityQueue()\n",
    "    frontier.put(init_node)\n",
    "    max_frontier = frontier.qsize() \n",
    "    \n",
    "    while not frontier.empty(): #looping while there are no more elements in the queue\n",
    "        \n",
    "        cur_node = frontier.get() #getting the highest priority node\n",
    "        \n",
    "        #if the current state is already a goal state, break\n",
    "        if cur_node.solved():\n",
    "            break\n",
    "        \n",
    "        #if the node was pruned, skip to the next element in the frontier\n",
    "        if cur_node.pruned:\n",
    "            continue \n",
    "        \n",
    "        #location of the black tile - 0\n",
    "        blank_tile = tuple(*np.argwhere(np.array(cur_node.state) == 0))\n",
    "        \n",
    "        movements = [(-1,0),(0,-1),(1,0),(0,1)] #existing movements\n",
    "        \n",
    "        #finding out the valid moves for a given state from which to further get to next states\n",
    "        #based on the location of the blank tile since we can only swap it with adjacent tiles\n",
    "        pos_moves=[]\n",
    "        for move in movements:\n",
    "            pos_moves.append(tuple([sum(x) for x in zip(blank_tile, move) if 0 <= sum(x) < n]))\n",
    "        \n",
    "        valid_moves = [move for move in pos_moves if len(move) == 2]\n",
    "        \n",
    "        for move in valid_moves: #new child state for each move in the valid moves list\n",
    "            #cost of a child for the current node\n",
    "            gval = cur_node.gval + 1 \n",
    "            \n",
    "            #creating child state configurations by making moves - swapping the blank tile with some adjacent tile\n",
    "            next_state = np.copy(cur_node.state)\n",
    "            next_state[blank_tile], next_state[move] = next_state[move], next_state[blank_tile] \n",
    "            \n",
    "            #checking if the child state was already explored\n",
    "            if tuple(next_state.flatten()) in explored:\n",
    "                #checking if the g-value of the child is higher than the g-value of the current node\n",
    "                if explored[tuple(next_state.flatten())].gval > gval:\n",
    "                    #if yes, prune the branch\n",
    "                    explored[tuple(next_state.flatten())].pruned = True\n",
    "                else:\n",
    "                    continue\n",
    "              \n",
    "            #CHANGED PART\n",
    "            #-----------------------------------------------------------\n",
    "            if tuple(next_state.flatten()) in global_explored: \n",
    "                #generating h-value\n",
    "                hval = global_explored[tuple(next_state.flatten())].hval\n",
    "            else:\n",
    "                hval = heuristic(next_state)\n",
    "\n",
    "            #creating the child node\n",
    "            node_next = PuzzleNode(n, fval = gval+hval, hval = hval, gval = gval, parent = cur_node, state = next_state)\n",
    "            frontier.put(node_next) #adding the child node to the priority queue\n",
    "            \n",
    "            #adding the child node to the explored set too, since we have explored it \n",
    "            explored[tuple(next_state.flatten())] = node_next\n",
    "            \n",
    "            if tuple(next_state.flatten()) not in global_explored:\n",
    "                global_explored[tuple(next_state.flatten())] = node_next\n",
    "            exp += 1 \n",
    "                \n",
    "        #update the max frontier size if relevant\n",
    "        if frontier.qsize() > max_frontier:\n",
    "            max_frontier = frontier.qsize()\n",
    "        \n",
    "    #if the current is solved, produce the optimal path\n",
    "    if cur_node.solved(): \n",
    "        opt_path = []\n",
    "        error = 0\n",
    "        \n",
    "        #while there are still parent nodes, continue adding to the optimal path\n",
    "        while cur_node is not None: \n",
    "            opt_path.insert(0, cur_node.state.tolist()) #add the parent of the current node \n",
    "            cur_node = cur_node.parent #update the current node to be the parent of itself\n",
    "        \n",
    "        steps = len(opt_path)-1 #number of steps it takes to reach the goal \n",
    "        \n",
    "        #TO SEE THE STEPS AND INFORMATION, UNCOMMENT THIS\n",
    "        #------------------------------------------------\n",
    "        \n",
    "#         print(f\"{steps} steps to solve the puzzle. Max frontier size:{max_frontier}\")\n",
    "#         for i, node in enumerate(opt_path[::]):\n",
    "#             print(f\"{i}: \\n\", list(list(j) for j in node))\n",
    "            \n",
    "    return(steps, exp, max_frontier, opt_path, 0)\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Total amount of time in search: 12.58596134185791 second(s)\n"
     ]
    }
   ],
   "source": [
    "import time\n",
    "tic = time.time()\n",
    "solvePuzzle(working_initial_states_8_puzzle[0], heuristics[0])\n",
    "solvePuzzle(working_initial_states_8_puzzle[1], heuristics[0])\n",
    "solvePuzzle(working_initial_states_8_puzzle[2], heuristics[0])\n",
    "toc = time.time()\n",
    "\n",
    "print(\"Total amount of time in search: \" + str(toc - tic) + \" second(s)\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Total amount of time in search for the memoization function (trial 1): 12.754853963851929 second(s)\n"
     ]
    }
   ],
   "source": [
    "#first trial when there are no nodes in the global_explored\n",
    "tic = time.time()\n",
    "solvePuzzle_memoization(working_initial_states_8_puzzle[0], heuristics[0])\n",
    "solvePuzzle_memoization(working_initial_states_8_puzzle[1], heuristics[0])\n",
    "solvePuzzle_memoization(working_initial_states_8_puzzle[2], heuristics[0])\n",
    "toc = time.time()\n",
    "\n",
    "print(\"Total amount of time in search for the memoization function (trial 1): \" + str(toc - tic) + \" second(s)\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Total amount of time in search for the memoization function (trial 2): 9.755086183547974 second(s)\n"
     ]
    }
   ],
   "source": [
    "#second trial, when there is already information\n",
    "tic = time.time()\n",
    "solvePuzzle_memoization(working_initial_states_8_puzzle[0], heuristics[0])\n",
    "solvePuzzle_memoization(working_initial_states_8_puzzle[1], heuristics[0])\n",
    "solvePuzzle_memoization(working_initial_states_8_puzzle[2], heuristics[0])\n",
    "toc = time.time()\n",
    "\n",
    "print(\"Total amount of time in search for the memoization function (trial 2): \" + str(toc - tic) + \" second(s)\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "code",
     "checksum": "af551e00bc8334100b7cf901ece597a2",
     "grade": true,
     "grade_id": "cell-09f710b6aa2e3fa3",
     "locked": true,
     "points": 64,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "outputs": [],
   "source": [
    "## Memoization test - will be carried out after submission"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.6"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 1
}
